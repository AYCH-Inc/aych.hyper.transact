/*
 * Copyright 2018 Bitwise IO, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * -----------------------------------------------------------------------------
 */
//! The `receipts` module contains structs that supply information on the
//! outcomes of transaction processing.  They supply information on the success
//! or failure of the transactions, and changes that may be applied to state.
//!
//! The `TransactionProcessingResult` and `BatchProcessingResult` have information
//! about the processing of transactions and batches.
//!
//! These results are not related to `std::result::Result`, in that they do not
//! represent issues that have resulted from aborted control flow but the
//! expected status of a transaction's result.

/// A change to be applied to state, in terms of keys and values.
///
/// A `StateChange` represents the basic level of changes that can be applied to
/// values in state.  This covers the setting of a key/value pair, or the
/// deletion of a key.
#[derive(Debug)]
pub enum StateChange<K, V> {
    Set { key: K, value: V },
    Delete { key: K },
}

impl<K, V> Clone for StateChange<K, V>
where
    K: Clone,
    V: Clone,
{
    fn clone(&self) -> Self {
        match self {
            StateChange::Set { key, value } => StateChange::Set {
                key: key.clone(),
                value: value.clone(),
            },
            StateChange::Delete { key } => StateChange::Delete { key: key.clone() },
        }
    }
}

/// An `InvalidTransaction` has information about why the transaction failed.
#[derive(Debug, Clone)]
pub struct InvalidTransaction {
    /// human readable reason for why the transaction was invalid.
    pub error_message: String,
    /// Transaction specific data that is returned to the client
    /// who submitted the Transaction.
    pub error_data: Vec<u8>,
}

/// A `TransactionReceipt` has the state changes associated with a valid transaction.
#[derive(Debug)]
pub struct TransactionReceipt<K, V> {
    /// Updates to state that were generated by the transaction.
    pub state_changes: Vec<StateChange<K, V>>,
    /// Events fired by this transaction.
    pub events: Vec<Event>,
    /// Transaction family defined data.
    pub data: Vec<Vec<u8>>,

    pub transaction_id: String,
}

/// An `Event` is metadata about a `Transaction`'s processing. Events are
/// transmitted by `transact` but are not verified or saved to state. `Event`s are
/// generated by any of the ways that `Transaction`s are processed in `transact`.
#[derive(Debug, Clone)]
pub struct Event {
    /// A human readable string that identifies this event
    /// Determined by the client.
    pub event_type: String,
    /// Human readable information about the transaction.
    pub attributes: Vec<(String, String)>,
    /// Opaque data, about the transaction, that the client can deserialize
    pub data: Vec<u8>,
}

/// The outcome of a transaction's execution.
///
/// A `TransactionStatus` covers the possible outcomes that can occur during a
/// transaction's execution.
#[derive(Debug)]
pub enum TransactionStatus<K, V> {
    Invalid(InvalidTransaction),
    Valid(TransactionReceipt<K, V>),
}

impl<K, V> Clone for TransactionStatus<K, V>
where
    K: Clone,
    V: Clone,
{
    fn clone(&self) -> Self {
        match self {
            TransactionStatus::Invalid(invalid_transaction) => {
                TransactionStatus::Invalid(InvalidTransaction {
                    error_message: invalid_transaction.error_message.clone(),
                    error_data: invalid_transaction.error_data.clone(),
                })
            }
            TransactionStatus::Valid(transaction_receipt) => {
                TransactionStatus::Valid(TransactionReceipt {
                    state_changes: transaction_receipt.state_changes.clone(),
                    events: transaction_receipt.events.clone(),
                    data: transaction_receipt.data.clone(),
                    transaction_id: transaction_receipt.transaction_id.clone(),
                })
            }
        }
    }
}

/// The `TransactionProcessingResult` provides the status for a given transaction.
#[derive(Debug)]
pub struct TransactionProcessingResult<K, V> {
    pub transaction_id: Vec<u8>,
    pub status: TransactionStatus<K, V>,
}

impl<K, V> Clone for TransactionProcessingResult<K, V>
where
    K: Clone,
    V: Clone,
{
    fn clone(&self) -> Self {
        Self {
            transaction_id: self.transaction_id.clone(),
            status: self.status.clone(),
        }
    }
}

/// A collection of `TransactionProcessingResult`s for transactions that are considered an
/// atomic unit of work.
#[derive(Debug)]
pub struct BatchProcessingResult<K, V> {
    pub batch_id: Vec<u8>,
    pub transaction_results: Vec<TransactionProcessingResult<K, V>>,
}

impl<K, V> Clone for BatchProcessingResult<K, V>
where
    K: Clone,
    V: Clone,
{
    fn clone(&self) -> Self {
        Self {
            batch_id: self.batch_id.clone(),
            transaction_results: self.transaction_results.clone(),
        }
    }
}
