/*
 * Copyright 2018 Bitwise IO, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * -----------------------------------------------------------------------------
 */
//! The `receipts` module contains structs that supply information on the
//! outcomes of transaction processing.  They supply information on the success
//! or failure of the transactions, and changes that may be applied to state.
//!
//! The `TransactionProcessingResult` and `BatchProcessingResult` have information
//! about the processing of transactions and batches.
//!
//! These results are not related to `std::result::Result`, in that they do not
//! represent issues that have resulted from aborted control flow but the
//! expected status of a transaction's result.

use super::protos;
use crate::protos::{FromNative, FromProto, IntoNative, IntoProto, ProtoConversionError};

/// A change to be applied to state, in terms of keys and values.
///
/// A `StateChange` represents the basic level of changes that can be applied to
/// values in state.  This covers the setting of a key/value pair, or the
/// deletion of a key.
#[derive(Debug)]
pub enum StateChange<K, V> {
    Set { key: K, value: V },
    Delete { key: K },
}

impl<K, V> Clone for StateChange<K, V>
where
    K: Clone,
    V: Clone,
{
    fn clone(&self) -> Self {
        match self {
            StateChange::Set { key, value } => StateChange::Set {
                key: key.clone(),
                value: value.clone(),
            },
            StateChange::Delete { key } => StateChange::Delete { key: key.clone() },
        }
    }
}

impl FromProto<protos::transaction_receipt::StateChange> for StateChange<String, Vec<u8>> {
    fn from_proto(
        state_change: protos::transaction_receipt::StateChange,
    ) -> Result<Self, ProtoConversionError> {
        match state_change.get_field_type() {
            protos::transaction_receipt::StateChange_Type::SET => Ok(StateChange::Set {
                key: state_change.get_address().to_string(),
                value: state_change.get_value().to_vec(),
            }),
            protos::transaction_receipt::StateChange_Type::DELETE => Ok(StateChange::Delete {
                key: state_change.get_address().to_string(),
            }),
            protos::transaction_receipt::StateChange_Type::TYPE_UNSET => {
                Err(ProtoConversionError::InvalidTypeError(
                    "Cannot convert StateChange with type unset. /
                    StageChange type must be StateChange_Type::SET or StateChange_Type::DELETE."
                        .to_string(),
                ))
            }
        }
    }
}

impl FromNative<StateChange<String, Vec<u8>>> for protos::transaction_receipt::StateChange {
    fn from_native(
        state_change: StateChange<String, Vec<u8>>,
    ) -> Result<Self, ProtoConversionError> {
        let mut proto_state_change = protos::transaction_receipt::StateChange::new();

        match state_change {
            StateChange::Set { key, value } => {
                proto_state_change.set_value(value);
                proto_state_change.set_address(key);
                proto_state_change
                    .set_field_type(protos::transaction_receipt::StateChange_Type::SET);
                Ok(proto_state_change)
            }
            StateChange::Delete { key } => {
                proto_state_change.set_address(key);
                proto_state_change
                    .set_field_type(protos::transaction_receipt::StateChange_Type::DELETE);
                Ok(proto_state_change)
            }
        }
    }
}

impl IntoProto<protos::transaction_receipt::StateChange> for StateChange<String, Vec<u8>> {}
impl IntoNative<StateChange<String, Vec<u8>>> for protos::transaction_receipt::StateChange {}

/// An `InvalidTransaction` has information about why the transaction failed.
#[derive(Debug, Clone)]
pub struct InvalidTransaction {
    /// human readable reason for why the transaction was invalid.
    pub error_message: String,
    /// Transaction specific data that is returned to the client
    /// who submitted the Transaction.
    pub error_data: Vec<u8>,
}

/// A `TransactionReceipt` has the state changes associated with a valid transaction.
#[derive(Debug)]
pub struct TransactionReceipt<K, V> {
    /// Updates to state that were generated by the transaction.
    pub state_changes: Vec<StateChange<K, V>>,
    /// Events fired by this transaction.
    pub events: Vec<Event>,
    /// Transaction family defined data.
    pub data: Vec<Vec<u8>>,

    pub transaction_id: String,
}

/// An `Event` is metadata about a `Transaction`'s processing. Events are
/// transmitted by `transact` but are not verified or saved to state. `Event`s are
/// generated by any of the ways that `Transaction`s are processed in `transact`.
#[derive(Debug, Clone, PartialEq)]
pub struct Event {
    /// A human readable string that identifies this event
    /// Determined by the client.
    pub event_type: String,
    /// Human readable information about the transaction.
    pub attributes: Vec<(String, String)>,
    /// Opaque data, about the transaction, that the client can deserialize
    pub data: Vec<u8>,
}

impl FromProto<protos::events::Event> for Event {
    fn from_proto(event: protos::events::Event) -> Result<Self, ProtoConversionError> {
        Ok(Event {
            event_type: event.get_event_type().to_string(),
            attributes: event
                .get_attributes()
                .to_vec()
                .into_iter()
                .map(|attr| (attr.get_key().to_string(), attr.get_value().to_string()))
                .collect(),
            data: event.get_data().to_vec(),
        })
    }
}

impl FromNative<Event> for protos::events::Event {
    fn from_native(event: Event) -> Result<Self, ProtoConversionError> {
        let mut proto_event = protos::events::Event::new();
        proto_event.set_event_type(event.event_type);
        proto_event.set_attributes(
            event
                .attributes
                .iter()
                .map(|(key, value)| {
                    let mut event_attr = protos::events::Event_Attribute::new();
                    event_attr.set_key(key.to_string());
                    event_attr.set_value(value.to_string());
                    event_attr
                })
                .collect::<protobuf::RepeatedField<protos::events::Event_Attribute>>(),
        );
        proto_event.set_data(event.data);
        Ok(proto_event)
    }
}

impl IntoProto<protos::events::Event> for Event {}
impl IntoNative<Event> for protos::events::Event {}

/// The outcome of a transaction's execution.
///
/// A `TransactionStatus` covers the possible outcomes that can occur during a
/// transaction's execution.
#[derive(Debug)]
pub enum TransactionStatus<K, V> {
    Invalid(InvalidTransaction),
    Valid(TransactionReceipt<K, V>),
}

impl<K, V> Clone for TransactionStatus<K, V>
where
    K: Clone,
    V: Clone,
{
    fn clone(&self) -> Self {
        match self {
            TransactionStatus::Invalid(invalid_transaction) => {
                TransactionStatus::Invalid(InvalidTransaction {
                    error_message: invalid_transaction.error_message.clone(),
                    error_data: invalid_transaction.error_data.clone(),
                })
            }
            TransactionStatus::Valid(transaction_receipt) => {
                TransactionStatus::Valid(TransactionReceipt {
                    state_changes: transaction_receipt.state_changes.clone(),
                    events: transaction_receipt.events.clone(),
                    data: transaction_receipt.data.clone(),
                    transaction_id: transaction_receipt.transaction_id.clone(),
                })
            }
        }
    }
}

/// The `TransactionProcessingResult` provides the status for a given transaction.
#[derive(Debug)]
pub struct TransactionProcessingResult<K, V> {
    pub transaction_id: Vec<u8>,
    pub status: TransactionStatus<K, V>,
}

impl<K, V> Clone for TransactionProcessingResult<K, V>
where
    K: Clone,
    V: Clone,
{
    fn clone(&self) -> Self {
        Self {
            transaction_id: self.transaction_id.clone(),
            status: self.status.clone(),
        }
    }
}

/// A collection of `TransactionProcessingResult`s for transactions that are considered an
/// atomic unit of work.
#[derive(Debug)]
pub struct BatchProcessingResult<K, V> {
    pub batch_id: Vec<u8>,
    pub transaction_results: Vec<TransactionProcessingResult<K, V>>,
}

impl<K, V> Clone for BatchProcessingResult<K, V>
where
    K: Clone,
    V: Clone,
{
    fn clone(&self) -> Self {
        Self {
            batch_id: self.batch_id.clone(),
            transaction_results: self.transaction_results.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    static ADDRESS: &str = "5b7349700e158b598043efd6d7610345a75a00b22ac14c9278db53f586179a92b72fbd";
    static BYTES1: [u8; 4] = [0x01, 0x02, 0x03, 0x04];
    static BYTES2: [u8; 4] = [0x05, 0x06, 0x07, 0x08];
    static EVENT_TYPE1: &str = "sawtooth/block-commit";
    static ATTR1: (&str, &str) = (
        "block_id",
        "f40b90d06b4a9074af2ab09e0187223da7466be75ec0f472 \
         f2edd5f22960d76e402e6c07c90b7816374891d698310dd25d9b88dce7dbcba8219d9f7c9cae1861",
    );
    static ATTR2: (&str, &str) = ("block_num", "3");
    fn make_event_1() -> Event {
        Event {
            event_type: EVENT_TYPE1.to_string(),
            attributes: vec![
                (ATTR1.0.to_string(), ATTR1.1.to_string()),
                (ATTR2.0.to_string(), ATTR2.1.to_string()),
            ],
            data: BYTES2.to_vec(),
        }
    }
    #[test]
    fn state_change_fields() {
        let state_change_set = StateChange::Set {
            key: ADDRESS.to_string(),
            value: BYTES1.to_vec(),
        };
        check_state_change(state_change_set);
        let state_change_delete = StateChange::Delete {
            key: ADDRESS.to_string(),
        };
        check_state_change(state_change_delete);
    }

    fn check_state_change(state_change: StateChange<String, Vec<u8>>) {
        match state_change {
            StateChange::Set { key, value } => {
                assert_eq!(ADDRESS, key);
                assert_eq!(BYTES1.to_vec(), value);
            }
            StateChange::Delete { key } => {
                assert_eq!(ADDRESS, key);
            }
        }
    }

    #[test]
    fn event_fields() {
        check_event(make_event_1());
    }

    fn check_event(event: Event) {
        assert_eq!(EVENT_TYPE1, event.event_type);
        assert_eq!(
            (ATTR1.0.to_string(), ATTR1.1.to_string()),
            event.attributes[0]
        );
        assert_eq!(
            (ATTR2.0.to_string(), ATTR2.1.to_string()),
            event.attributes[1]
        );
        assert_eq!(BYTES2.to_vec(), event.data);
    }

}
